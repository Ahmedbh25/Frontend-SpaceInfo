import React__default from 'react';
import { useController } from './Controller.js';

/**
 * `AccessabilityOrientation` definition used for the `SliderProps.orientation` prop.
 * Used to define which swipes (depending on directions) will change the slides,
 * and where and how will the buttons render, if set to render.
 */
var AccessabilityOrientation;
(function (AccessabilityOrientation) {
    AccessabilityOrientation["VERTICAL"] = "vertical";
    AccessabilityOrientation["HORIZONTAL"] = "horizontal";
})(AccessabilityOrientation || (AccessabilityOrientation = {}));
const defaultProps = {
    shouldDisplayButtons: true,
    shouldSlideOnArrowKeypress: true,
    orientation: AccessabilityOrientation.HORIZONTAL,
    thresholdToSlide: 50
};
const AccessabilityStateContext = React__default.createContext(undefined);
function accessabilityReducer(state, action) {
    switch (action.type) {
        case 'start-motion': {
            return {
                initialX: action.payload.x,
                initialY: action.payload.y,
                currentX: undefined,
                currentY: undefined
            };
        }
        case 'update-motion': {
            return {
                initialX: state.initialX,
                initialY: state.initialY,
                currentX: action.payload.x,
                currentY: action.payload.y
            };
        }
        case 'end-motion': {
            return {
                initialX: undefined,
                initialY: undefined,
                currentX: undefined,
                currentY: undefined
            };
        }
        default: {
            throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);
        }
    }
}
function AccessabilityProvider({ children, accessability }) {
    var _a, _b, _c;
    const params = {
        shouldDisplayButtons: (_a = accessability === null || accessability === void 0 ? void 0 : accessability.shouldDisplayButtons) !== null && _a !== void 0 ? _a : defaultProps.shouldDisplayButtons,
        shouldSlideOnArrowKeypress: (_b = accessability === null || accessability === void 0 ? void 0 : accessability.shouldSlideOnArrowKeypress) !== null && _b !== void 0 ? _b : defaultProps.shouldSlideOnArrowKeypress,
        orientation: (accessability === null || accessability === void 0 ? void 0 : accessability.orientation) || defaultProps.orientation,
        thresholdToSlide: (_c = accessability === null || accessability === void 0 ? void 0 : accessability.thresholdToSlide) !== null && _c !== void 0 ? _c : defaultProps.thresholdToSlide
    };
    const [state, dispatch] = React__default.useReducer(accessabilityReducer, {
        initialX: undefined,
        initialY: undefined,
        currentX: undefined,
        currentY: undefined
    });
    const { goToNextSlide, goToPreviousSlide } = useController();
    /**
     * Sets the initial coordinates of the touch event.
     */
    const onTouchStartHandler = (event) => {
        dispatch({
            type: 'start-motion',
            payload: {
                x: event.touches[0].clientX,
                y: event.touches[0].clientY
            }
        });
    };
    /**
     * Sets the current coordinates of the touch event to the state.
     */
    const onTouchMoveHandler = (event) => {
        dispatch({
            type: 'update-motion',
            payload: {
                x: event.touches[0].clientX,
                y: event.touches[0].clientY
            }
        });
    };
    /**
     * Determines in which direction **and** sense (vector) the user is swiping.
     * Animations are then set accordingly depending on which direction the user is dragging and the slide is changed.
     * Finally the touch state is set back to the initial state, where everything is undefined.
     */
    const onTouchEndHandler = () => {
        const diffX = Number(state.initialX) - Number(state.currentX);
        const diffY = Number(state.initialY) - Number(state.currentY);
        const isSlidingHorizontally = Math.abs(diffX) > Math.abs(diffY);
        const isSliderSetHorizontally = params.orientation === AccessabilityOrientation.HORIZONTAL;
        const isSliderVertically = params.orientation === AccessabilityOrientation.VERTICAL;
        if (isSlidingHorizontally &&
            isSliderSetHorizontally &&
            Math.abs(diffX) >= params.thresholdToSlide) {
            const isSwipingRight = diffX > 0;
            if (isSwipingRight)
                goToNextSlide();
            else
                goToPreviousSlide();
        }
        else if (isSliderVertically &&
            Math.abs(diffY) >= params.thresholdToSlide) {
            const isSwipingUp = diffY > 0;
            if (isSwipingUp)
                goToNextSlide();
            else
                goToPreviousSlide();
        }
        dispatch({ type: 'end-motion' });
    };
    const onArrowKeypressHandler = (e) => {
        if (!params.shouldSlideOnArrowKeypress)
            return;
        const isHorizontal = params.orientation === AccessabilityOrientation.HORIZONTAL;
        switch (true) {
            // Left keypress.
            case isHorizontal && e.keyCode === 37:
                goToPreviousSlide();
                break;
            // Right keypress.
            case isHorizontal && e.keyCode === 39:
                goToNextSlide();
                break;
            // Up keypress.
            case !isHorizontal && e.keyCode === 38:
                goToPreviousSlide();
                break;
            // Down keypress.
            case !isHorizontal && e.keyCode === 40:
                goToNextSlide();
                break;
        }
    };
    /**
     * After mounting, similar to `componentDidMount`, setup the window event listeners for keydowns. The event handlers will be changing the slides if enabled to do so.
     */
    React__default.useEffect(() => {
        window.addEventListener('keydown', onArrowKeypressHandler);
        /**
         * Clearing any existing timeouts to avoid memory leaks, and clear event listener.
         */
        return () => {
            window.removeEventListener('keydown', onArrowKeypressHandler);
        };
    }, [onArrowKeypressHandler]);
    // NOTE: you *might* need to memoize this value
    // Learn more in http://kcd.im/optimize-context
    const value = {
        state,
        shouldDisplayButtons: params.shouldDisplayButtons,
        orientation: params.orientation,
        onTouchStartHandler,
        onTouchMoveHandler,
        onTouchEndHandler
    };
    return (React__default.createElement(AccessabilityStateContext.Provider, { value: value }, children));
}
function useAccessability() {
    const context = React__default.useContext(AccessabilityStateContext);
    if (context === undefined) {
        throw new Error('useAccessability must be used within a AccessabilityProvider');
    }
    return context;
}

export { AccessabilityOrientation, AccessabilityProvider, useAccessability };
//# sourceMappingURL=Accessability.js.map
