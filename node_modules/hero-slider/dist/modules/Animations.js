import React__default from 'react';
import HeroSliderModuleCss from '../HeroSlider.module.css.js';
import { useAccessability, AccessabilityOrientation } from './Accessability.js';

var SlidingAnimation;
(function (SlidingAnimation) {
    SlidingAnimation["TOP_TO_BOTTOM"] = "top_to_bottom";
    SlidingAnimation["BOTTOM_TO_TOP"] = "bottom_to_top";
    SlidingAnimation["LEFT_TO_RIGHT"] = "left_to_right";
    SlidingAnimation["RIGHT_TO_LEFT"] = "right_to_left";
    SlidingAnimation["FADE"] = "fade";
})(SlidingAnimation || (SlidingAnimation = {}));
const SlidingAnimationCssClassMap = {
    [SlidingAnimation.FADE]: HeroSliderModuleCss.Sliding_Fade_In,
    [SlidingAnimation.TOP_TO_BOTTOM]: HeroSliderModuleCss.Sliding_Top_To_Bottom,
    [SlidingAnimation.BOTTOM_TO_TOP]: HeroSliderModuleCss.Sliding_Bottom_To_Top,
    [SlidingAnimation.LEFT_TO_RIGHT]: HeroSliderModuleCss.Sliding_Left_To_Right,
    [SlidingAnimation.RIGHT_TO_LEFT]: HeroSliderModuleCss.Sliding_Right_To_Left
};
const defaultProps = {
    slidingAnimation: 'wipe',
    sliderFadeInDuration: 100,
    navbarFadeInDuration: 1000,
    navbarFadeInDelay: 500,
    shouldManageAnimationSequence: true
};
const AnimationsStateContext = React__default.createContext(undefined);
function AnimationsProvider({ children, animations }) {
    var _a, _b, _c, _d;
    const { orientation } = useAccessability();
    const params = {
        slidingAnimation: (animations === null || animations === void 0 ? void 0 : animations.slidingAnimation) || defaultProps.slidingAnimation,
        sliderFadeInDuration: (_a = animations === null || animations === void 0 ? void 0 : animations.sliderFadeInDuration) !== null && _a !== void 0 ? _a : defaultProps.sliderFadeInDuration,
        navbarFadeInDuration: (_b = animations === null || animations === void 0 ? void 0 : animations.navbarFadeInDuration) !== null && _b !== void 0 ? _b : defaultProps.navbarFadeInDuration,
        navbarFadeInDelay: (_c = animations === null || animations === void 0 ? void 0 : animations.navbarFadeInDelay) !== null && _c !== void 0 ? _c : defaultProps.navbarFadeInDelay,
        shouldManageAnimationSequence: (_d = animations === null || animations === void 0 ? void 0 : animations.shouldManageAnimationSequence) !== null && _d !== void 0 ? _d : defaultProps.shouldManageAnimationSequence
    };
    const getSlidingAnimationCssClass = (activeSlide, prevActiveSlide, slidingDirection) => {
        const getSlidingAnimation = () => {
            switch (params.slidingAnimation) {
                case 'fade':
                    return SlidingAnimation.FADE;
                case 'wipe': {
                    let direction;
                    if (slidingDirection)
                        direction = slidingDirection;
                    else {
                        const isSlidingForward = activeSlide > prevActiveSlide;
                        direction = isSlidingForward ? 'forward' : 'backward';
                    }
                    if (direction === 'forward')
                        return orientation === AccessabilityOrientation.HORIZONTAL
                            ? SlidingAnimation.RIGHT_TO_LEFT
                            : SlidingAnimation.BOTTOM_TO_TOP;
                    else
                        return orientation === AccessabilityOrientation.HORIZONTAL
                            ? SlidingAnimation.LEFT_TO_RIGHT
                            : SlidingAnimation.TOP_TO_BOTTOM;
                }
                default: {
                    throw new Error(`Unhandled sliding animation: [${params.slidingAnimation}]`);
                }
            }
        };
        return SlidingAnimationCssClassMap[getSlidingAnimation()];
    };
    // NOTE: you *might* need to memoize this value
    // Learn more in http://kcd.im/optimize-context
    const value = {
        sliderFadeInDuration: params.sliderFadeInDuration,
        navbarFadeInDuration: params.sliderFadeInDuration,
        navbarFadeInDelay: params.sliderFadeInDuration,
        getSlidingAnimationCssClass
    };
    return (React__default.createElement(AnimationsStateContext.Provider, { value: value }, children));
}
function useAnimations() {
    const context = React__default.useContext(AnimationsStateContext);
    if (context === undefined) {
        throw new Error('useAnimations must be used within a AnimationsProvider');
    }
    return context;
}

export { AnimationsProvider, useAnimations };
//# sourceMappingURL=Animations.js.map
