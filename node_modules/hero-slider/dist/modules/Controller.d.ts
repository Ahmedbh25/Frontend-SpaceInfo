/// <reference types="node" />
import React from 'react';
interface GetNextSlide {
    (aSlide?: number): number;
}
interface GetPreviousSlide {
    (aSlide?: number): number;
}
interface ChangeSlide {
    (nextSlide: number, slidingDirection?: 'forward' | 'backward'): void;
}
interface GoToNextSlide {
    (): void;
}
interface GoToPreviousSlide {
    (): void;
}
interface GetSlidingCycleDuration {
    (): number;
}
export interface ControllerProps {
    /**
     * Sliding duration, in milliseconds.
     * @default 500
     */
    slidingDuration?: number;
    /**
     * Sliding delay, in milliseconds.
     * @default 200
     */
    slidingDelay?: number;
    /**
     * The initial slide can also be set, but the slider starts at the first slide by default.
     * @default 1
     */
    initialSlide?: number;
    /**
     * Callback executed before sliding begins.
     * The previous and next slide numbers are received as arguments, since the sliding event can be delayed, this is useful to handle state changes from the outside (e.g. fire custom animations inside the active slide).
     * @param activeSlide
     * @param nextSlide
     * @default undefined
     */
    onBeforeSliding?(activeSlide: number, nextSlide: number): void;
    /**
     * Callback executed after the sliding ends similar to `onBeforeSliding`.
     * @param activeSlide
     * @param prevSlide
     * @default undefined
     */
    onSliding?(activeSlide: number, prevSlide: number): void;
    /**
     * Callback executed after the sliding ends similar to `onBeforeChange`.
     * @param activeSlide
     * @param prevSlide
     * @default undefined
     */
    onAfterSliding?(activeSlide: number, prevSlide: number): void;
    /**
     * Similar to pointers in C++, objects can work like pointers in JavaScript. React references are mutable objects that can be changed but will always point to an origin. If you declare an `object` and pass it as a reference, then the `current` property of the React reference `object` will be set to be equal to the `goToNextSlide` handler within the slider. This provides the developer with a way to change the slides "from the outside" of the bounds of the HeroSlider component.
     */
    goToNextSlidePointer?: React.MutableRefObject<GoToNextSlide | undefined>;
    /**
     * Similar to `nextSlide`, this sets the `object` to be equal to the `goToPreviousSlide` handler within the HeroSlider component.
     */
    goToPreviousSlidePointer?: React.MutableRefObject<GoToPreviousSlide | undefined>;
}
interface State {
    activeSlide: number;
    prevActiveSlide: number;
    isSliding: boolean;
    slidingDirection: 'forward' | 'backward' | undefined;
    delayTimeout?: NodeJS.Timeout;
    slidingTimeout?: NodeJS.Timeout;
}
declare type ProviderProps = React.PropsWithChildren<{
    controller?: ControllerProps;
}>;
declare function ControllerProvider({ children, controller }: ProviderProps): JSX.Element;
declare function useController(): {
    state: State;
    slidingDuration: number;
    slidingDelay: number;
    getNextSlide: GetNextSlide;
    getPreviousSlide: GetPreviousSlide;
    getSlidingCycleDuration: GetSlidingCycleDuration;
    changeSlide: ChangeSlide;
    goToNextSlide: GoToNextSlide;
    goToPreviousSlide: GoToPreviousSlide;
};
export { ControllerProvider, useController };
//# sourceMappingURL=Controller.d.ts.map