import React__default from 'react';
import IntervalTimer, { IntervalState } from './IntervalTimer.js';
import { useController } from './Controller.js';
import { useIntersectionObserver } from './IntersectionObserver.js';
import ConsoleLogger from './ConsoleLogger.js';

const logger = ConsoleLogger.new();
const defaultProps = {
    autoplayDuration: 8000,
    autoplayDebounce: 4000
};
const AutoplayStateContext = React__default.createContext(undefined);
function autoplayReducer(state, action) {
    switch (action.type) {
        case 'pause': {
            return Object.assign(Object.assign({}, state), { isPausedByUser: true });
        }
        case 'resume': {
            return Object.assign(Object.assign({}, state), { isPausedByUser: false });
        }
        case 'set-debounce-timeout': {
            return Object.assign(Object.assign({}, state), { debounceTimeout: action.payload });
        }
        default: {
            throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);
        }
    }
}
function AutoplayProvider({ children, autoplay }) {
    var _a, _b;
    const params = {
        autoplayDuration: (_a = (typeof autoplay === 'object' ? autoplay === null || autoplay === void 0 ? void 0 : autoplay.autoplayDuration : undefined)) !== null && _a !== void 0 ? _a : defaultProps.autoplayDuration,
        autoplayDebounce: (_b = (typeof autoplay === 'object' ? autoplay === null || autoplay === void 0 ? void 0 : autoplay.autoplayDebounce : undefined)) !== null && _b !== void 0 ? _b : defaultProps.autoplayDebounce
    };
    const [state, dispatch] = React__default.useReducer(autoplayReducer, {
        isPausedByUser: false,
        debounceTimeout: undefined
    });
    const { state: controller, changeSlide, getNextSlide, getSlidingCycleDuration } = useController();
    const slidingCycleDuration = getSlidingCycleDuration();
    const autoplayCycleDuration = Math.max(slidingCycleDuration, params.autoplayDuration);
    if (params.autoplayDuration < getSlidingCycleDuration())
        logger.warn('[Autoplay] The `autoplayDuration` is lower than the sliding cycle duration (the result of `slidingDuration + slidingDelay`).', 'The sliding cycle duration will be used instead for the autoplay intervals.');
    const autoplayInstance = IntervalTimer.new(() => {
        changeSlide(getNextSlide(controller.activeSlide));
    }, autoplayCycleDuration);
    const { isInView } = useIntersectionObserver();
    /**
     * Debounces the autoplay interval whene called.
     */
    const debounce = () => {
        const isPausedOrIdle = autoplayInstance.state === IntervalState.IDLE || state.isPausedByUser;
        if (isPausedOrIdle)
            return; // If the slider has been paused, do nothing.
        autoplayInstance.pause();
        if (state.debounceTimeout)
            clearTimeout(state.debounceTimeout);
        dispatch({
            type: 'set-debounce-timeout',
            payload: setTimeout(autoplayInstance.resume, params.autoplayDebounce)
        });
    };
    /**
     * Pauses the autoplay.
     */
    const pause = () => {
        logger.debug('[Autoplay] Paused by user.');
        autoplayInstance.pause();
        dispatch({ type: 'pause' });
    };
    /**
     * Resumes the autoplay.
     */
    const resume = () => {
        logger.debug('[Autoplay] Resumed by user.');
        autoplayInstance.resume();
        dispatch({ type: 'resume' });
    };
    /**
     * When the user pauses the slider, clear any debounced timeouts.
     */
    React__default.useEffect(() => {
        if (state.isPausedByUser)
            clearTimeout(state.debounceTimeout);
        return () => { };
    }, [state.isPausedByUser]);
    /**
     * Subscribe to changes in `autoplay` and `isInView`.
     * If the slider goes out of the viewport, then pause the slider autoplay instance if it's not idle.
     * If it comes back into viewport and its idle, start or resume the autoplay instance.
     * If the autoplay is disabled, then stop.
     */
    React__default.useEffect(() => {
        if (autoplay) {
            switch (true) {
                case state.isPausedByUser:
                    break;
                // When not in view, stop the autoplay.
                case !isInView && autoplayInstance.state !== IntervalState.IDLE:
                    autoplayInstance.stop();
                    logger.debug('[Autoplay] Stopped.');
                    break;
                // When in view and idle, start it.
                case isInView && autoplayInstance.state === IntervalState.IDLE: {
                    autoplayInstance.start();
                    logger.debug('[Autoplay] Started.');
                    break;
                }
                // When in view and paused, resume it.
                case isInView && autoplayInstance.state === IntervalState.PAUSED: {
                    autoplayInstance.resume();
                    logger.debug('[Autoplay] Resumed.');
                    break;
                }
            }
        }
        else if (autoplayInstance.state !== IntervalState.IDLE) {
            autoplayInstance.stop();
            logger.info('[Autoplay] Stopped.');
        }
    }, [autoplay, isInView]);
    /**
     * Clearing any existing timeouts to avoid memory leaks, and clear event listener.
     */
    React__default.useEffect(() => {
        return () => {
            clearTimeout(state.debounceTimeout);
            autoplayInstance.stop();
        };
    }, []);
    /**
     * When the slide changes, clear any debounced timeouts, after the slide finishes, the
     * autoplay resets.
     */
    React__default.useEffect(() => {
        clearTimeout(state.debounceTimeout);
        return () => { };
    }, [controller.activeSlide]);
    // NOTE: you *might* need to memoize this value
    // Learn more in http://kcd.im/optimize-context
    const value = {
        state,
        autoplayState: autoplayInstance.state,
        debounce,
        pause,
        resume
    };
    return (React__default.createElement(AutoplayStateContext.Provider, { value: value }, children));
}
function useAutoplay() {
    const context = React__default.useContext(AutoplayStateContext);
    if (context === undefined) {
        throw new Error('useAutoplay must be used within a AutoplayProvider');
    }
    return context;
}

export { AutoplayProvider, useAutoplay };
//# sourceMappingURL=Autoplay.js.map
