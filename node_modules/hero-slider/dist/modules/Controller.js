import React__default from 'react';
import { useManager } from './Manager.js';

const defaultProps = {
    slidingDuration: 500,
    slidingDelay: 200,
    initialSlide: 1
};
const ControllerStateContext = React__default.createContext(undefined);
function settingsReducer(state, action) {
    switch (action.type) {
        case 'start-sliding': {
            return Object.assign(Object.assign({}, state), { isSliding: true, activeSlide: action.payload.nextSlide, prevActiveSlide: state.activeSlide, slidingDirection: action.payload.slidingDirection });
        }
        case 'finish-sliding': {
            return Object.assign(Object.assign({}, state), { isSliding: false, slidingDirection: undefined });
        }
        case 'set-delay-timeout': {
            return Object.assign(Object.assign({}, state), { delayTimeout: action.payload });
        }
        case 'set-sliding-timeout': {
            return Object.assign(Object.assign({}, state), { slidingTimeout: action.payload });
        }
        default: {
            throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);
        }
    }
}
function ControllerProvider({ children, controller }) {
    var _a, _b;
    const params = {
        slidingDuration: (_a = controller === null || controller === void 0 ? void 0 : controller.slidingDuration) !== null && _a !== void 0 ? _a : defaultProps.slidingDuration,
        slidingDelay: (_b = controller === null || controller === void 0 ? void 0 : controller.slidingDelay) !== null && _b !== void 0 ? _b : defaultProps.slidingDelay,
        initialSlide: (controller === null || controller === void 0 ? void 0 : controller.initialSlide) || defaultProps.initialSlide
    };
    const [state, dispatch] = React__default.useReducer(settingsReducer, {
        activeSlide: params.initialSlide,
        prevActiveSlide: 0,
        isSliding: false,
        slidingDirection: undefined,
        delayTimeout: undefined,
        slidingTimeout: undefined
    });
    const { state: manager } = useManager();
    /**
     * Returns the slide after the given slide (`activeSlide` by default) based on the total amount of slides.
     */
    const getNextSlide = (aSlide = state.activeSlide) => {
        const lastSlide = manager.totalSlides;
        const isNotLastSlide = aSlide <= lastSlide - 1;
        let nextSlide;
        if (isNotLastSlide)
            nextSlide = aSlide + 1;
        else
            nextSlide = 1;
        return nextSlide;
    };
    /**
     * Returns the previous slide similarly to `getNextSlide`.
     */
    const getPreviousSlide = (aSlide = state.activeSlide) => {
        const lastSlide = manager.totalSlides;
        const isNotFirstSlide = aSlide > 1;
        let nextSlide;
        if (isNotFirstSlide)
            nextSlide = aSlide - 1;
        else
            nextSlide = lastSlide;
        return nextSlide;
    };
    /**
     * Returns the total time it takes for the transition of each slide. It's the sum of the duration of the slide, plus the sliding delay of the animation. A safety factor of 1.1 is also used.
     * e.g.: `(slidingDuration + slidingDelay) * 1.1`
     */
    const getSlidingCycleDuration = () => {
        return (params.slidingDuration + params.slidingDelay) * 1.1; // 110% safety factor.
    };
    /**
     * `changeSlide` sets a new slide then executes `onSlidingHandler` to handle
     * the smooth transition and set `isDoneSlidingWatcher.current` (like a pointer)
     * as true. While `isDoneSliding` is true, no the slides won't change.
     * The `onBeforeSliding` event is executed here. This triggers a useEffect
     * that handles effects after the sliding is done.
     */
    const changeSlide = (nextSlide, slidingDirection) => {
        if (state.isSliding)
            return;
        if (controller === null || controller === void 0 ? void 0 : controller.onBeforeSliding)
            controller.onBeforeSliding(state.activeSlide, nextSlide);
        dispatch({
            type: 'start-sliding',
            payload: {
                nextSlide,
                slidingDirection
            }
        });
    };
    /**
     * Changes the active slide to the next one.
     */
    const goToNextSlide = () => {
        changeSlide(getNextSlide(state.activeSlide), 'forward');
    };
    /**
     * Changes the active slide to the previous one.
     */
    const goToPreviousSlide = () => {
        changeSlide(getPreviousSlide(state.activeSlide), 'backward');
    };
    /**
     * Sets up the `goToNextSlide` pointer if it exists.
     */
    React__default.useEffect(() => {
        if (controller === null || controller === void 0 ? void 0 : controller.goToNextSlidePointer)
            controller.goToNextSlidePointer.current = goToNextSlide;
    }, [controller === null || controller === void 0 ? void 0 : controller.goToNextSlidePointer, goToNextSlide]);
    /**
     * Sets up the `previousSlide` reference object if they exist.
     */
    React__default.useEffect(() => {
        if (controller === null || controller === void 0 ? void 0 : controller.goToPreviousSlidePointer)
            controller.goToPreviousSlidePointer.current = goToPreviousSlide;
    }, [controller === null || controller === void 0 ? void 0 : controller.goToPreviousSlidePointer, goToNextSlide]);
    /**
     * Starts a `setTimeout` that will set `isSliding` as `false` after the time it takes for the slide to change passes.
     * Saves the timeout ID to `slidingTimeout`. The `onSliding` and `onAfterSliding` events are executed here.
     */
    React__default.useEffect(() => {
        dispatch({
            type: 'set-delay-timeout',
            payload: setTimeout(() => {
                if (controller === null || controller === void 0 ? void 0 : controller.onSliding)
                    controller.onSliding(state.activeSlide, state.prevActiveSlide);
            }, params.slidingDelay)
        });
        dispatch({
            type: 'set-sliding-timeout',
            payload: setTimeout(() => {
                dispatch({ type: 'finish-sliding' });
                if (controller === null || controller === void 0 ? void 0 : controller.onAfterSliding)
                    controller.onAfterSliding(state.activeSlide, state.prevActiveSlide);
            }, getSlidingCycleDuration())
        });
        /**
         * Clearing any existing timeouts to avoid memory leaks, and clear event listener.
         */
        return () => {
            if (state.delayTimeout)
                clearTimeout(state.delayTimeout);
            if (state.slidingTimeout)
                clearTimeout(state.slidingTimeout);
        };
    }, [state.activeSlide]);
    // NOTE: you *might* need to memoize this value
    // Learn more in http://kcd.im/optimize-context
    const value = {
        state,
        slidingDuration: params.slidingDuration,
        slidingDelay: params.slidingDelay,
        getNextSlide,
        getPreviousSlide,
        getSlidingCycleDuration,
        changeSlide,
        goToNextSlide,
        goToPreviousSlide
    };
    return (React__default.createElement(ControllerStateContext.Provider, { value: value }, children));
}
function useController() {
    const context = React__default.useContext(ControllerStateContext);
    if (context === undefined) {
        throw new Error('useController must be used within a ControllerProvider');
    }
    return context;
}

export { ControllerProvider, useController };
//# sourceMappingURL=Controller.js.map
