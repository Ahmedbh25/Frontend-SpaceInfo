{"version":3,"file":"Autoplay.js","sources":["../../src/modules/Autoplay.tsx"],"sourcesContent":["import React from 'react';\nimport IntervalTimer, { IntervalState } from './IntervalTimer';\nimport { useController } from './Controller';\nimport { useIntersectionObserver } from './IntersectionObserver';\nimport ConsoleLogger from './ConsoleLogger';\n\nconst logger = ConsoleLogger.new();\n\ninterface Props {\n  /**\n   * Autoplay duration, interval or duration betweens slide transitions, in milliseconds.\n   * If it's lower than the sliding cycle duration (sliding duration + sliding delay), then the sliding cycle duration will be used instead.\n   * @default 8000\n   */\n  autoplayDuration?: number;\n  /**\n   * Time (in milliseconds) in which the autoplay will be debounced if the user interacts with the slider.\n   * The autoplay resumes if the user stops interacting after this duration.\n   * Set as 0 to disable this feature.\n   * @default 4000\n   */\n  autoplayDebounce?: number;\n}\n\nexport type AutoplayProps = Props | boolean;\n\ntype Action =\n  | { type: 'pause' }\n  | { type: 'resume' }\n  | { type: 'set-debounce-timeout'; payload: NodeJS.Timeout };\ninterface State {\n  isPausedByUser: boolean;\n  debounceTimeout?: NodeJS.Timeout;\n}\ntype ProviderProps = React.PropsWithChildren<{\n  autoplay?: AutoplayProps;\n}>;\n\nconst defaultProps: Required<Props> = {\n  autoplayDuration: 8000,\n  autoplayDebounce: 4000\n};\n\nconst AutoplayStateContext = React.createContext<\n  | {\n      state: State;\n      autoplayState: IntervalState;\n      debounce: () => void;\n      pause: () => void;\n      resume: () => void;\n    }\n  | undefined\n>(undefined);\n\nfunction autoplayReducer(state: State, action: Action): State {\n  switch (action.type) {\n    case 'pause': {\n      return { ...state, isPausedByUser: true };\n    }\n    case 'resume': {\n      return { ...state, isPausedByUser: false };\n    }\n    case 'set-debounce-timeout': {\n      return { ...state, debounceTimeout: action.payload };\n    }\n    default: {\n      throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);\n    }\n  }\n}\n\nfunction AutoplayProvider({ children, autoplay }: ProviderProps) {\n  const params: Required<Props> = {\n    autoplayDuration:\n      (typeof autoplay === 'object' ? autoplay?.autoplayDuration : undefined) ??\n      defaultProps.autoplayDuration,\n    autoplayDebounce:\n      (typeof autoplay === 'object' ? autoplay?.autoplayDebounce : undefined) ??\n      defaultProps.autoplayDebounce\n  };\n\n  const [state, dispatch] = React.useReducer(autoplayReducer, {\n    isPausedByUser: false,\n    debounceTimeout: undefined\n  } as State);\n\n  const {\n    state: controller,\n    changeSlide,\n    getNextSlide,\n    getSlidingCycleDuration\n  } = useController();\n\n  const slidingCycleDuration = getSlidingCycleDuration();\n\n  const autoplayCycleDuration = Math.max(\n    slidingCycleDuration,\n    params.autoplayDuration\n  );\n\n  if (params.autoplayDuration < getSlidingCycleDuration())\n    logger.warn(\n      '[Autoplay] The `autoplayDuration` is lower than the sliding cycle duration (the result of `slidingDuration + slidingDelay`).',\n      'The sliding cycle duration will be used instead for the autoplay intervals.'\n    );\n\n  const autoplayInstance = IntervalTimer.new((): void => {\n    changeSlide(getNextSlide(controller.activeSlide));\n  }, autoplayCycleDuration);\n\n  const { isInView } = useIntersectionObserver();\n\n  /**\n   * Debounces the autoplay interval whene called.\n   */\n  const debounce = (): void => {\n    const isPausedOrIdle =\n      autoplayInstance.state === IntervalState.IDLE || state.isPausedByUser;\n\n    if (isPausedOrIdle) return; // If the slider has been paused, do nothing.\n\n    autoplayInstance.pause();\n\n    if (state.debounceTimeout) clearTimeout(state.debounceTimeout);\n\n    dispatch({\n      type: 'set-debounce-timeout',\n      payload: setTimeout(autoplayInstance.resume, params.autoplayDebounce)\n    });\n  };\n\n  /**\n   * Pauses the autoplay.\n   */\n  const pause = (): void => {\n    logger.debug('[Autoplay] Paused by user.');\n    autoplayInstance.pause();\n    dispatch({ type: 'pause' });\n  };\n\n  /**\n   * Resumes the autoplay.\n   */\n  const resume = (): void => {\n    logger.debug('[Autoplay] Resumed by user.');\n    autoplayInstance.resume();\n    dispatch({ type: 'resume' });\n  };\n\n  /**\n   * When the user pauses the slider, clear any debounced timeouts.\n   */\n  React.useEffect(() => {\n    if (state.isPausedByUser) clearTimeout(state.debounceTimeout);\n    return () => {};\n  }, [state.isPausedByUser]);\n\n  /**\n   * Subscribe to changes in `autoplay` and `isInView`.\n   * If the slider goes out of the viewport, then pause the slider autoplay instance if it's not idle.\n   * If it comes back into viewport and its idle, start or resume the autoplay instance.\n   * If the autoplay is disabled, then stop.\n   */\n  React.useEffect(() => {\n    if (autoplay) {\n      switch (true) {\n        case state.isPausedByUser:\n          break;\n        // When not in view, stop the autoplay.\n        case !isInView && autoplayInstance.state !== IntervalState.IDLE:\n          autoplayInstance.stop();\n          logger.debug('[Autoplay] Stopped.');\n          break;\n        // When in view and idle, start it.\n        case isInView && autoplayInstance.state === IntervalState.IDLE: {\n          autoplayInstance.start();\n          logger.debug('[Autoplay] Started.');\n          break;\n        }\n        // When in view and paused, resume it.\n        case isInView && autoplayInstance.state === IntervalState.PAUSED: {\n          autoplayInstance.resume();\n          logger.debug('[Autoplay] Resumed.');\n          break;\n        }\n      }\n    } else if (autoplayInstance.state !== IntervalState.IDLE) {\n      autoplayInstance.stop();\n      logger.info('[Autoplay] Stopped.');\n    }\n  }, [autoplay, isInView]);\n\n  /**\n   * Clearing any existing timeouts to avoid memory leaks, and clear event listener.\n   */\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(state.debounceTimeout);\n      autoplayInstance.stop();\n    };\n  }, []);\n\n  /**\n   * When the slide changes, clear any debounced timeouts, after the slide finishes, the\n   * autoplay resets.\n   */\n  React.useEffect(() => {\n    clearTimeout(state.debounceTimeout);\n    return () => {};\n  }, [controller.activeSlide]);\n\n  // NOTE: you *might* need to memoize this value\n  // Learn more in http://kcd.im/optimize-context\n  const value = {\n    state,\n    autoplayState: autoplayInstance.state,\n    debounce,\n    pause,\n    resume\n  };\n\n  return (\n    <AutoplayStateContext.Provider value={value}>\n      {children}\n    </AutoplayStateContext.Provider>\n  );\n}\n\nfunction useAutoplay() {\n  const context = React.useContext(AutoplayStateContext);\n\n  if (context === undefined) {\n    throw new Error('useAutoplay must be used within a AutoplayProvider');\n  }\n\n  return context;\n}\n\nexport { AutoplayProvider, useAutoplay };\n"],"names":["React"],"mappings":"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"}