{"version":3,"file":"IntervalTimer.js","sources":["../../src/modules/IntervalTimer.ts"],"sourcesContent":["export enum IntervalState {\n  IDLE,\n  RUNNING,\n  PAUSED,\n  RESUME\n}\n\n/**\n * `IntervalTimer` is a class that handles logic for intervals, e.g. start stop, reset, resume, pause & maximum amount of fires.\n */\nexport default class IntervalTimer {\n  /**\n   * The state to handle logic.\n   * - 0 means the interval is idle.\n   * - 1 means it's running.\n   * - 2 means it's paused\n   * - 3 will resume.\n   */\n  public state: IntervalState = IntervalState.IDLE;\n\n  /**\n   * Remaining time before the next interval.\n   */\n  public remaining: number = 0;\n\n  /**\n   * Amount of times fired.\n   */\n  public fires: number = 0;\n\n  /**\n   * Time passed after pausing,\n   */\n  public pausedTime: number | Date = 0;\n\n  private lastTimeFired?: Date;\n  private timerId?: NodeJS.Timer;\n  private resumeId?: NodeJS.Timeout;\n  private lastPauseTime?: Date;\n\n  private constructor(\n    /**\n     * Called after every interval.\n     */\n    public callback: () => void,\n    /**\n     * Time between intervals, in milliseconds.\n     */\n    public interval: number,\n    /**\n     * Maximum amount of fires.\n     */\n    public maxFires?: number\n  ) {}\n\n  /**\n   * Handles the callback execution, the amount of fires, & the times when fired.\n   * If `this.maxFires` is **not** null, and it's bigger than `this.fires` and if `this.fires` exists, meaning if it the interval was at least started once before, then never fire again.\n   */\n  private intervalHandler = () => {\n    if (\n      this.maxFires != null &&\n      this.fires !== 0 &&\n      this.fires >= this.maxFires\n    ) {\n      this.stop();\n    } else {\n      this.lastTimeFired = new Date();\n      this.fires += 1;\n      this.callback();\n    }\n  };\n\n  /**\n   * `timeoutHandler` is executed by `resume`. `timeoutHandler` is the callback of a new `setTimeout` executed by `resume` to mimic a resume function.\n   * The callback is executed by running `intervalHandler`, and then `start` is executed to run a new interval.\n   */\n  private timeoutHandler = () => {\n    if (this.state !== IntervalState.RESUME) return;\n\n    this.pausedTime = 0;\n    this.intervalHandler();\n    this.start();\n  };\n\n  /**\n   * `start` executes the interval, and saves the interval ID for further use.\n   * The time of execution is also fired in case it's paused later on. The state\n   * is finally set as running.\n   */\n  public start = () => {\n    this.timerId = setInterval(this.intervalHandler, this.interval);\n    this.lastTimeFired = new Date();\n    this.state = IntervalState.RUNNING;\n  };\n\n  /**\n   * `stop` clears every respective timeout and interval, then sets the state as idle.\n   */\n  public stop = () => {\n    if (this.state === 0) return;\n\n    clearInterval(this.timerId);\n    clearTimeout(this.resumeId);\n    this.state = IntervalState.IDLE;\n  };\n\n  /**\n   * Resets the interval.\n   */\n  public reset = () => {\n    this.stop();\n    this.start();\n  };\n\n  /**\n   * `pause` tries to mimic pausing the interval by calculating the remaining time and storing it\n   * in a member variable. Afterwards clear the respective timeout and interval then set the new\n   * state.\n   */\n  public pause = () => {\n    if (\n      this.state !== IntervalState.RUNNING &&\n      this.state !== IntervalState.RESUME\n    )\n      return;\n\n    this.remaining =\n      +this.interval -\n      (+new Date() - +(this.lastTimeFired || 0)) +\n      +this.pausedTime;\n    this.lastPauseTime = new Date();\n    clearInterval(this.timerId);\n    clearTimeout(this.resumeId);\n    this.state = IntervalState.PAUSED;\n  };\n\n  /**\n   * `resume` calculates the remaining time for the callback to trigger using the values\n   * set by `paused`. Will execute a new `setTimeout` while passing the `remaining` time\n   * as the timeout delay.\n   */\n  public resume = () => {\n    if (this.state !== IntervalState.PAUSED) return;\n    const currentDate = new Date();\n    this.pausedTime =\n      +this.pausedTime + +currentDate - +(this.lastPauseTime || 0);\n    this.state = IntervalState.RESUME;\n    this.resumeId = setTimeout(this.timeoutHandler, this.remaining);\n  };\n\n  /**\n   * Set a new interval to use on the next interval loop.\n   */\n  public setInterval = (newInterval: number) => {\n    if (this.state === 1) {\n      // If running we need to instantiate (new ID) the variable.\n      this.pause();\n      this.interval = newInterval;\n      this.resume();\n    } else {\n      // If stopped, idle, or paused then switch it.\n      this.interval = newInterval;\n    }\n  };\n\n  /**\n   * Maximum amount of times the `callback` member will execute, it's infinite by default.\n   */\n  public setMaxFires = (newMax: number) => {\n    if (newMax != null && this.fires >= newMax) {\n      this.stop();\n    }\n    this.maxFires = newMax;\n  };\n\n  private static instance: IntervalTimer | undefined;\n\n  public static new(\n    callback: () => void,\n    interval: number,\n    maxFires: number | undefined = undefined\n  ): IntervalTimer {\n    if (!this.instance)\n      this.instance = new IntervalTimer(callback, interval, maxFires);\n    else {\n      this.instance.callback = callback;\n      this.instance.interval = interval;\n      this.instance.maxFires = maxFires;\n    }\n    return this.instance;\n  }\n}\n"],"names":[],"mappings":"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"}