{"ast":null,"code":"var IntervalState;\n(function (IntervalState) {\n  IntervalState[IntervalState[\"IDLE\"] = 0] = \"IDLE\";\n  IntervalState[IntervalState[\"RUNNING\"] = 1] = \"RUNNING\";\n  IntervalState[IntervalState[\"PAUSED\"] = 2] = \"PAUSED\";\n  IntervalState[IntervalState[\"RESUME\"] = 3] = \"RESUME\";\n})(IntervalState || (IntervalState = {}));\n/**\n * `IntervalTimer` is a class that handles logic for intervals, e.g. start stop, reset, resume, pause & maximum amount of fires.\n */\nclass IntervalTimer {\n  constructor(\n  /**\n   * Called after every interval.\n   */\n  callback,\n  /**\n   * Time between intervals, in milliseconds.\n   */\n  interval,\n  /**\n   * Maximum amount of fires.\n   */\n  maxFires) {\n    this.callback = callback;\n    this.interval = interval;\n    this.maxFires = maxFires;\n    /**\n     * The state to handle logic.\n     * - 0 means the interval is idle.\n     * - 1 means it's running.\n     * - 2 means it's paused\n     * - 3 will resume.\n     */\n    this.state = IntervalState.IDLE;\n    /**\n     * Remaining time before the next interval.\n     */\n    this.remaining = 0;\n    /**\n     * Amount of times fired.\n     */\n    this.fires = 0;\n    /**\n     * Time passed after pausing,\n     */\n    this.pausedTime = 0;\n    /**\n     * Handles the callback execution, the amount of fires, & the times when fired.\n     * If `this.maxFires` is **not** null, and it's bigger than `this.fires` and if `this.fires` exists, meaning if it the interval was at least started once before, then never fire again.\n     */\n    this.intervalHandler = () => {\n      if (this.maxFires != null && this.fires !== 0 && this.fires >= this.maxFires) {\n        this.stop();\n      } else {\n        this.lastTimeFired = new Date();\n        this.fires += 1;\n        this.callback();\n      }\n    };\n    /**\n     * `timeoutHandler` is executed by `resume`. `timeoutHandler` is the callback of a new `setTimeout` executed by `resume` to mimic a resume function.\n     * The callback is executed by running `intervalHandler`, and then `start` is executed to run a new interval.\n     */\n    this.timeoutHandler = () => {\n      if (this.state !== IntervalState.RESUME) return;\n      this.pausedTime = 0;\n      this.intervalHandler();\n      this.start();\n    };\n    /**\n     * `start` executes the interval, and saves the interval ID for further use.\n     * The time of execution is also fired in case it's paused later on. The state\n     * is finally set as running.\n     */\n    this.start = () => {\n      this.timerId = setInterval(this.intervalHandler, this.interval);\n      this.lastTimeFired = new Date();\n      this.state = IntervalState.RUNNING;\n    };\n    /**\n     * `stop` clears every respective timeout and interval, then sets the state as idle.\n     */\n    this.stop = () => {\n      if (this.state === 0) return;\n      clearInterval(this.timerId);\n      clearTimeout(this.resumeId);\n      this.state = IntervalState.IDLE;\n    };\n    /**\n     * Resets the interval.\n     */\n    this.reset = () => {\n      this.stop();\n      this.start();\n    };\n    /**\n     * `pause` tries to mimic pausing the interval by calculating the remaining time and storing it\n     * in a member variable. Afterwards clear the respective timeout and interval then set the new\n     * state.\n     */\n    this.pause = () => {\n      if (this.state !== IntervalState.RUNNING && this.state !== IntervalState.RESUME) return;\n      this.remaining = +this.interval - (+new Date() - +(this.lastTimeFired || 0)) + +this.pausedTime;\n      this.lastPauseTime = new Date();\n      clearInterval(this.timerId);\n      clearTimeout(this.resumeId);\n      this.state = IntervalState.PAUSED;\n    };\n    /**\n     * `resume` calculates the remaining time for the callback to trigger using the values\n     * set by `paused`. Will execute a new `setTimeout` while passing the `remaining` time\n     * as the timeout delay.\n     */\n    this.resume = () => {\n      if (this.state !== IntervalState.PAUSED) return;\n      const currentDate = new Date();\n      this.pausedTime = +this.pausedTime + +currentDate - +(this.lastPauseTime || 0);\n      this.state = IntervalState.RESUME;\n      this.resumeId = setTimeout(this.timeoutHandler, this.remaining);\n    };\n    /**\n     * Set a new interval to use on the next interval loop.\n     */\n    this.setInterval = newInterval => {\n      if (this.state === 1) {\n        // If running we need to instantiate (new ID) the variable.\n        this.pause();\n        this.interval = newInterval;\n        this.resume();\n      } else {\n        // If stopped, idle, or paused then switch it.\n        this.interval = newInterval;\n      }\n    };\n    /**\n     * Maximum amount of times the `callback` member will execute, it's infinite by default.\n     */\n    this.setMaxFires = newMax => {\n      if (newMax != null && this.fires >= newMax) {\n        this.stop();\n      }\n      this.maxFires = newMax;\n    };\n  }\n  static new(callback, interval) {\n    let maxFires = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    if (!this.instance) this.instance = new IntervalTimer(callback, interval, maxFires);else {\n      this.instance.callback = callback;\n      this.instance.interval = interval;\n      this.instance.maxFires = maxFires;\n    }\n    return this.instance;\n  }\n}\nexport { IntervalState, IntervalTimer as default };","map":{"version":3,"mappings":"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","names":["IntervalState","IntervalTimer","constructor","callback","interval","maxFires","IDLE","fires","stop","lastTimeFired","Date","state","RESUME","pausedTime","intervalHandler","start","timerId","setInterval","RUNNING","clearInterval","clearTimeout","resumeId","remaining","lastPauseTime","PAUSED","currentDate","setTimeout","timeoutHandler","newInterval","pause","resume","newMax","new","undefined","instance"],"sources":["/home/hana/Desktop/Projects/level1/space-infoPC/client/node_modules/hero-slider/src/modules/IntervalTimer.ts"],"sourcesContent":["export enum IntervalState {\n  IDLE,\n  RUNNING,\n  PAUSED,\n  RESUME\n}\n\n/**\n * `IntervalTimer` is a class that handles logic for intervals, e.g. start stop, reset, resume, pause & maximum amount of fires.\n */\nexport default class IntervalTimer {\n  /**\n   * The state to handle logic.\n   * - 0 means the interval is idle.\n   * - 1 means it's running.\n   * - 2 means it's paused\n   * - 3 will resume.\n   */\n  public state: IntervalState = IntervalState.IDLE;\n\n  /**\n   * Remaining time before the next interval.\n   */\n  public remaining: number = 0;\n\n  /**\n   * Amount of times fired.\n   */\n  public fires: number = 0;\n\n  /**\n   * Time passed after pausing,\n   */\n  public pausedTime: number | Date = 0;\n\n  private lastTimeFired?: Date;\n  private timerId?: NodeJS.Timer;\n  private resumeId?: NodeJS.Timeout;\n  private lastPauseTime?: Date;\n\n  private constructor(\n    /**\n     * Called after every interval.\n     */\n    public callback: () => void,\n    /**\n     * Time between intervals, in milliseconds.\n     */\n    public interval: number,\n    /**\n     * Maximum amount of fires.\n     */\n    public maxFires?: number\n  ) {}\n\n  /**\n   * Handles the callback execution, the amount of fires, & the times when fired.\n   * If `this.maxFires` is **not** null, and it's bigger than `this.fires` and if `this.fires` exists, meaning if it the interval was at least started once before, then never fire again.\n   */\n  private intervalHandler = () => {\n    if (\n      this.maxFires != null &&\n      this.fires !== 0 &&\n      this.fires >= this.maxFires\n    ) {\n      this.stop();\n    } else {\n      this.lastTimeFired = new Date();\n      this.fires += 1;\n      this.callback();\n    }\n  };\n\n  /**\n   * `timeoutHandler` is executed by `resume`. `timeoutHandler` is the callback of a new `setTimeout` executed by `resume` to mimic a resume function.\n   * The callback is executed by running `intervalHandler`, and then `start` is executed to run a new interval.\n   */\n  private timeoutHandler = () => {\n    if (this.state !== IntervalState.RESUME) return;\n\n    this.pausedTime = 0;\n    this.intervalHandler();\n    this.start();\n  };\n\n  /**\n   * `start` executes the interval, and saves the interval ID for further use.\n   * The time of execution is also fired in case it's paused later on. The state\n   * is finally set as running.\n   */\n  public start = () => {\n    this.timerId = setInterval(this.intervalHandler, this.interval);\n    this.lastTimeFired = new Date();\n    this.state = IntervalState.RUNNING;\n  };\n\n  /**\n   * `stop` clears every respective timeout and interval, then sets the state as idle.\n   */\n  public stop = () => {\n    if (this.state === 0) return;\n\n    clearInterval(this.timerId);\n    clearTimeout(this.resumeId);\n    this.state = IntervalState.IDLE;\n  };\n\n  /**\n   * Resets the interval.\n   */\n  public reset = () => {\n    this.stop();\n    this.start();\n  };\n\n  /**\n   * `pause` tries to mimic pausing the interval by calculating the remaining time and storing it\n   * in a member variable. Afterwards clear the respective timeout and interval then set the new\n   * state.\n   */\n  public pause = () => {\n    if (\n      this.state !== IntervalState.RUNNING &&\n      this.state !== IntervalState.RESUME\n    )\n      return;\n\n    this.remaining =\n      +this.interval -\n      (+new Date() - +(this.lastTimeFired || 0)) +\n      +this.pausedTime;\n    this.lastPauseTime = new Date();\n    clearInterval(this.timerId);\n    clearTimeout(this.resumeId);\n    this.state = IntervalState.PAUSED;\n  };\n\n  /**\n   * `resume` calculates the remaining time for the callback to trigger using the values\n   * set by `paused`. Will execute a new `setTimeout` while passing the `remaining` time\n   * as the timeout delay.\n   */\n  public resume = () => {\n    if (this.state !== IntervalState.PAUSED) return;\n    const currentDate = new Date();\n    this.pausedTime =\n      +this.pausedTime + +currentDate - +(this.lastPauseTime || 0);\n    this.state = IntervalState.RESUME;\n    this.resumeId = setTimeout(this.timeoutHandler, this.remaining);\n  };\n\n  /**\n   * Set a new interval to use on the next interval loop.\n   */\n  public setInterval = (newInterval: number) => {\n    if (this.state === 1) {\n      // If running we need to instantiate (new ID) the variable.\n      this.pause();\n      this.interval = newInterval;\n      this.resume();\n    } else {\n      // If stopped, idle, or paused then switch it.\n      this.interval = newInterval;\n    }\n  };\n\n  /**\n   * Maximum amount of times the `callback` member will execute, it's infinite by default.\n   */\n  public setMaxFires = (newMax: number) => {\n    if (newMax != null && this.fires >= newMax) {\n      this.stop();\n    }\n    this.maxFires = newMax;\n  };\n\n  private static instance: IntervalTimer | undefined;\n\n  public static new(\n    callback: () => void,\n    interval: number,\n    maxFires: number | undefined = undefined\n  ): IntervalTimer {\n    if (!this.instance)\n      this.instance = new IntervalTimer(callback, interval, maxFires);\n    else {\n      this.instance.callback = callback;\n      this.instance.interval = interval;\n      this.instance.maxFires = maxFires;\n    }\n    return this.instance;\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}