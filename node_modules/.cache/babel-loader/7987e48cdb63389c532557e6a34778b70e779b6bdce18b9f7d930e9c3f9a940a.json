{"ast":null,"code":"import React__default from 'react';\nimport IntervalTimer, { IntervalState } from './IntervalTimer.js';\nimport { useController } from './Controller.js';\nimport { useIntersectionObserver } from './IntersectionObserver.js';\nimport ConsoleLogger from './ConsoleLogger.js';\nconst logger = ConsoleLogger.new();\nconst defaultProps = {\n  autoplayDuration: 8000,\n  autoplayDebounce: 4000\n};\nconst AutoplayStateContext = React__default.createContext(undefined);\nfunction autoplayReducer(state, action) {\n  switch (action.type) {\n    case 'pause':\n      {\n        return Object.assign(Object.assign({}, state), {\n          isPausedByUser: true\n        });\n      }\n    case 'resume':\n      {\n        return Object.assign(Object.assign({}, state), {\n          isPausedByUser: false\n        });\n      }\n    case 'set-debounce-timeout':\n      {\n        return Object.assign(Object.assign({}, state), {\n          debounceTimeout: action.payload\n        });\n      }\n    default:\n      {\n        throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);\n      }\n  }\n}\nfunction AutoplayProvider(_ref) {\n  let {\n    children,\n    autoplay\n  } = _ref;\n  var _a, _b;\n  const params = {\n    autoplayDuration: (_a = typeof autoplay === 'object' ? autoplay === null || autoplay === void 0 ? void 0 : autoplay.autoplayDuration : undefined) !== null && _a !== void 0 ? _a : defaultProps.autoplayDuration,\n    autoplayDebounce: (_b = typeof autoplay === 'object' ? autoplay === null || autoplay === void 0 ? void 0 : autoplay.autoplayDebounce : undefined) !== null && _b !== void 0 ? _b : defaultProps.autoplayDebounce\n  };\n  const [state, dispatch] = React__default.useReducer(autoplayReducer, {\n    isPausedByUser: false,\n    debounceTimeout: undefined\n  });\n  const {\n    state: controller,\n    changeSlide,\n    getNextSlide,\n    getSlidingCycleDuration\n  } = useController();\n  const slidingCycleDuration = getSlidingCycleDuration();\n  const autoplayCycleDuration = Math.max(slidingCycleDuration, params.autoplayDuration);\n  if (params.autoplayDuration < getSlidingCycleDuration()) logger.warn('[Autoplay] The `autoplayDuration` is lower than the sliding cycle duration (the result of `slidingDuration + slidingDelay`).', 'The sliding cycle duration will be used instead for the autoplay intervals.');\n  const autoplayInstance = IntervalTimer.new(() => {\n    changeSlide(getNextSlide(controller.activeSlide));\n  }, autoplayCycleDuration);\n  const {\n    isInView\n  } = useIntersectionObserver();\n  /**\n   * Debounces the autoplay interval whene called.\n   */\n  const debounce = () => {\n    const isPausedOrIdle = autoplayInstance.state === IntervalState.IDLE || state.isPausedByUser;\n    if (isPausedOrIdle) return; // If the slider has been paused, do nothing.\n    autoplayInstance.pause();\n    if (state.debounceTimeout) clearTimeout(state.debounceTimeout);\n    dispatch({\n      type: 'set-debounce-timeout',\n      payload: setTimeout(autoplayInstance.resume, params.autoplayDebounce)\n    });\n  };\n  /**\n   * Pauses the autoplay.\n   */\n  const pause = () => {\n    logger.debug('[Autoplay] Paused by user.');\n    autoplayInstance.pause();\n    dispatch({\n      type: 'pause'\n    });\n  };\n  /**\n   * Resumes the autoplay.\n   */\n  const resume = () => {\n    logger.debug('[Autoplay] Resumed by user.');\n    autoplayInstance.resume();\n    dispatch({\n      type: 'resume'\n    });\n  };\n  /**\n   * When the user pauses the slider, clear any debounced timeouts.\n   */\n  React__default.useEffect(() => {\n    if (state.isPausedByUser) clearTimeout(state.debounceTimeout);\n    return () => {};\n  }, [state.isPausedByUser]);\n  /**\n   * Subscribe to changes in `autoplay` and `isInView`.\n   * If the slider goes out of the viewport, then pause the slider autoplay instance if it's not idle.\n   * If it comes back into viewport and its idle, start or resume the autoplay instance.\n   * If the autoplay is disabled, then stop.\n   */\n  React__default.useEffect(() => {\n    if (autoplay) {\n      switch (true) {\n        case state.isPausedByUser:\n          break;\n        // When not in view, stop the autoplay.\n        case !isInView && autoplayInstance.state !== IntervalState.IDLE:\n          autoplayInstance.stop();\n          logger.debug('[Autoplay] Stopped.');\n          break;\n        // When in view and idle, start it.\n        case isInView && autoplayInstance.state === IntervalState.IDLE:\n          {\n            autoplayInstance.start();\n            logger.debug('[Autoplay] Started.');\n            break;\n          }\n        // When in view and paused, resume it.\n        case isInView && autoplayInstance.state === IntervalState.PAUSED:\n          {\n            autoplayInstance.resume();\n            logger.debug('[Autoplay] Resumed.');\n            break;\n          }\n      }\n    } else if (autoplayInstance.state !== IntervalState.IDLE) {\n      autoplayInstance.stop();\n      logger.info('[Autoplay] Stopped.');\n    }\n  }, [autoplay, isInView]);\n  /**\n   * Clearing any existing timeouts to avoid memory leaks, and clear event listener.\n   */\n  React__default.useEffect(() => {\n    return () => {\n      clearTimeout(state.debounceTimeout);\n      autoplayInstance.stop();\n    };\n  }, []);\n  /**\n   * When the slide changes, clear any debounced timeouts, after the slide finishes, the\n   * autoplay resets.\n   */\n  React__default.useEffect(() => {\n    clearTimeout(state.debounceTimeout);\n    return () => {};\n  }, [controller.activeSlide]);\n  // NOTE: you *might* need to memoize this value\n  // Learn more in http://kcd.im/optimize-context\n  const value = {\n    state,\n    autoplayState: autoplayInstance.state,\n    debounce,\n    pause,\n    resume\n  };\n  return React__default.createElement(AutoplayStateContext.Provider, {\n    value: value\n  }, children);\n}\nfunction useAutoplay() {\n  const context = React__default.useContext(AutoplayStateContext);\n  if (context === undefined) {\n    throw new Error('useAutoplay must be used within a AutoplayProvider');\n  }\n  return context;\n}\nexport { AutoplayProvider, useAutoplay };","map":{"version":3,"mappings":"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","names":["logger","ConsoleLogger","new","defaultProps","autoplayDuration","autoplayDebounce","AutoplayStateContext","React","createContext","undefined","autoplayReducer","state","action","type","isPausedByUser","debounceTimeout","payload","Error","stringify","AutoplayProvider","children","autoplay","params","dispatch","useReducer","controller","changeSlide","getNextSlide","getSlidingCycleDuration","useController","slidingCycleDuration","autoplayCycleDuration","Math","max","warn","autoplayInstance","IntervalTimer","activeSlide","isInView","useIntersectionObserver","debounce","isPausedOrIdle","IntervalState","IDLE","pause","clearTimeout","setTimeout","resume","debug","useEffect","stop","start","PAUSED","info","value","autoplayState","Provider","useAutoplay","context","useContext"],"sources":["/home/hana/Desktop/Projects/level1/space-infoPC/client/node_modules/hero-slider/src/modules/Autoplay.tsx"],"sourcesContent":["import React from 'react';\nimport IntervalTimer, { IntervalState } from './IntervalTimer';\nimport { useController } from './Controller';\nimport { useIntersectionObserver } from './IntersectionObserver';\nimport ConsoleLogger from './ConsoleLogger';\n\nconst logger = ConsoleLogger.new();\n\ninterface Props {\n  /**\n   * Autoplay duration, interval or duration betweens slide transitions, in milliseconds.\n   * If it's lower than the sliding cycle duration (sliding duration + sliding delay), then the sliding cycle duration will be used instead.\n   * @default 8000\n   */\n  autoplayDuration?: number;\n  /**\n   * Time (in milliseconds) in which the autoplay will be debounced if the user interacts with the slider.\n   * The autoplay resumes if the user stops interacting after this duration.\n   * Set as 0 to disable this feature.\n   * @default 4000\n   */\n  autoplayDebounce?: number;\n}\n\nexport type AutoplayProps = Props | boolean;\n\ntype Action =\n  | { type: 'pause' }\n  | { type: 'resume' }\n  | { type: 'set-debounce-timeout'; payload: NodeJS.Timeout };\ninterface State {\n  isPausedByUser: boolean;\n  debounceTimeout?: NodeJS.Timeout;\n}\ntype ProviderProps = React.PropsWithChildren<{\n  autoplay?: AutoplayProps;\n}>;\n\nconst defaultProps: Required<Props> = {\n  autoplayDuration: 8000,\n  autoplayDebounce: 4000\n};\n\nconst AutoplayStateContext = React.createContext<\n  | {\n      state: State;\n      autoplayState: IntervalState;\n      debounce: () => void;\n      pause: () => void;\n      resume: () => void;\n    }\n  | undefined\n>(undefined);\n\nfunction autoplayReducer(state: State, action: Action): State {\n  switch (action.type) {\n    case 'pause': {\n      return { ...state, isPausedByUser: true };\n    }\n    case 'resume': {\n      return { ...state, isPausedByUser: false };\n    }\n    case 'set-debounce-timeout': {\n      return { ...state, debounceTimeout: action.payload };\n    }\n    default: {\n      throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);\n    }\n  }\n}\n\nfunction AutoplayProvider({ children, autoplay }: ProviderProps) {\n  const params: Required<Props> = {\n    autoplayDuration:\n      (typeof autoplay === 'object' ? autoplay?.autoplayDuration : undefined) ??\n      defaultProps.autoplayDuration,\n    autoplayDebounce:\n      (typeof autoplay === 'object' ? autoplay?.autoplayDebounce : undefined) ??\n      defaultProps.autoplayDebounce\n  };\n\n  const [state, dispatch] = React.useReducer(autoplayReducer, {\n    isPausedByUser: false,\n    debounceTimeout: undefined\n  } as State);\n\n  const {\n    state: controller,\n    changeSlide,\n    getNextSlide,\n    getSlidingCycleDuration\n  } = useController();\n\n  const slidingCycleDuration = getSlidingCycleDuration();\n\n  const autoplayCycleDuration = Math.max(\n    slidingCycleDuration,\n    params.autoplayDuration\n  );\n\n  if (params.autoplayDuration < getSlidingCycleDuration())\n    logger.warn(\n      '[Autoplay] The `autoplayDuration` is lower than the sliding cycle duration (the result of `slidingDuration + slidingDelay`).',\n      'The sliding cycle duration will be used instead for the autoplay intervals.'\n    );\n\n  const autoplayInstance = IntervalTimer.new((): void => {\n    changeSlide(getNextSlide(controller.activeSlide));\n  }, autoplayCycleDuration);\n\n  const { isInView } = useIntersectionObserver();\n\n  /**\n   * Debounces the autoplay interval whene called.\n   */\n  const debounce = (): void => {\n    const isPausedOrIdle =\n      autoplayInstance.state === IntervalState.IDLE || state.isPausedByUser;\n\n    if (isPausedOrIdle) return; // If the slider has been paused, do nothing.\n\n    autoplayInstance.pause();\n\n    if (state.debounceTimeout) clearTimeout(state.debounceTimeout);\n\n    dispatch({\n      type: 'set-debounce-timeout',\n      payload: setTimeout(autoplayInstance.resume, params.autoplayDebounce)\n    });\n  };\n\n  /**\n   * Pauses the autoplay.\n   */\n  const pause = (): void => {\n    logger.debug('[Autoplay] Paused by user.');\n    autoplayInstance.pause();\n    dispatch({ type: 'pause' });\n  };\n\n  /**\n   * Resumes the autoplay.\n   */\n  const resume = (): void => {\n    logger.debug('[Autoplay] Resumed by user.');\n    autoplayInstance.resume();\n    dispatch({ type: 'resume' });\n  };\n\n  /**\n   * When the user pauses the slider, clear any debounced timeouts.\n   */\n  React.useEffect(() => {\n    if (state.isPausedByUser) clearTimeout(state.debounceTimeout);\n    return () => {};\n  }, [state.isPausedByUser]);\n\n  /**\n   * Subscribe to changes in `autoplay` and `isInView`.\n   * If the slider goes out of the viewport, then pause the slider autoplay instance if it's not idle.\n   * If it comes back into viewport and its idle, start or resume the autoplay instance.\n   * If the autoplay is disabled, then stop.\n   */\n  React.useEffect(() => {\n    if (autoplay) {\n      switch (true) {\n        case state.isPausedByUser:\n          break;\n        // When not in view, stop the autoplay.\n        case !isInView && autoplayInstance.state !== IntervalState.IDLE:\n          autoplayInstance.stop();\n          logger.debug('[Autoplay] Stopped.');\n          break;\n        // When in view and idle, start it.\n        case isInView && autoplayInstance.state === IntervalState.IDLE: {\n          autoplayInstance.start();\n          logger.debug('[Autoplay] Started.');\n          break;\n        }\n        // When in view and paused, resume it.\n        case isInView && autoplayInstance.state === IntervalState.PAUSED: {\n          autoplayInstance.resume();\n          logger.debug('[Autoplay] Resumed.');\n          break;\n        }\n      }\n    } else if (autoplayInstance.state !== IntervalState.IDLE) {\n      autoplayInstance.stop();\n      logger.info('[Autoplay] Stopped.');\n    }\n  }, [autoplay, isInView]);\n\n  /**\n   * Clearing any existing timeouts to avoid memory leaks, and clear event listener.\n   */\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(state.debounceTimeout);\n      autoplayInstance.stop();\n    };\n  }, []);\n\n  /**\n   * When the slide changes, clear any debounced timeouts, after the slide finishes, the\n   * autoplay resets.\n   */\n  React.useEffect(() => {\n    clearTimeout(state.debounceTimeout);\n    return () => {};\n  }, [controller.activeSlide]);\n\n  // NOTE: you *might* need to memoize this value\n  // Learn more in http://kcd.im/optimize-context\n  const value = {\n    state,\n    autoplayState: autoplayInstance.state,\n    debounce,\n    pause,\n    resume\n  };\n\n  return (\n    <AutoplayStateContext.Provider value={value}>\n      {children}\n    </AutoplayStateContext.Provider>\n  );\n}\n\nfunction useAutoplay() {\n  const context = React.useContext(AutoplayStateContext);\n\n  if (context === undefined) {\n    throw new Error('useAutoplay must be used within a AutoplayProvider');\n  }\n\n  return context;\n}\n\nexport { AutoplayProvider, useAutoplay };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}